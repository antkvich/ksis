
Итак, нам нужно написать прокси-сервер.
Из чего будет состоять наша программа?

Точно должен быть поток, который будет принимать входящие подключения.
Нужна сущность ProxyConnection, которая инкапсулирует в себе два потока.
Первый поток слушает вход от клиентского сокета, а второй - от серверного.
Клиентский сокет получается с помощью ServerSocket, а серверный создаётся самостоятельно.
Серверный сокет будет создаваться при получении первого http-запроса от клиента.

Условно то, как работает поток, слушающий клиентский сокет, можно описать так:
1) ждём пока не придёт что-то на входной поток
2) считываем http-запрос
3) если клиентский сокет не инициализирован, то
    создаём клиентский сокет на основе поля URL-request
4) отправляем считанный http-запрос по серверному сокету
5) если присутствует Connection: close, то
    закрываем соединение

Условно то, как работает поток, слушающий серверный сокет, можно описать так:
1) ждём пока не придёт что-то на входной поток
2) считываем http-ответ
3) журналируем ответ
4) отправлям считанный http-ответ по клиентскому сокету
5) если присутствует Connection: close, то
    закрываем соединение

Как лучше всего реализовать считывание http-запроса и http-ответа?
Наверное лучше всего это релизовать через отдельные классы типа HttpRequestReader и HttpResponseReader.
HttpRequestReader будет возвращать объект типа HttpRequest.
HttpResponseReader будет возвращать объект типа HttpResponse.

Клиент может устанавливать с сервером несколько соединений параллельно. В принципе это не проблема, каждое
такое соединение будет обслуживаться отдельно. Еще есть такой момент, что одно соединение может быть
использовано для отправки множества запросов и ответов. В принципе тоже не так уж и проблематично, нужно лишь
разграничить потоки и обеспечить разграничение http-сообщений. Еще на данном этапе делается гипотеза, что
все http-запросы имеют один и тот же целевой адрес в рамках одного и того же TCP-соединения.

По сути ко мне могут приходить запросы с Connection: close и с Connection: keep-alive.
Первый тип требует того, чтобы я закрыл соединение сразу после того, как я передам ресурс.
Второй тип требует того, чтобы я не закрывал соединение, а поддерживал его открытым до поры до времени.
Вопрос: как это лучше всего замутить в коде?

Ну всё всегда начинается с клиента. Он в любом случае отправляет мне http-запрос. Значит я всегда могу узнать
адрес назначения.

Есть идея сделать общий HttpReader, от которого будут наследоваться HttpRequestReader и HttpResponseReader.
Я бы хотел в дочерних классах определять лишь набор заголовков, а также набор обработчиков для этих значений.
Когда встречается заданное значение, вызывается обработчик, аргумент которого принимает

Возникает следующий момент. У запроса и ответа различаются форматы первых строк. Еще лучше всего отделить первую
строку и заголовки от тела. Вопрос: как это лучше всего замутить? Давайте так, я не хочу переносить логику чтения
в классы самих сообщений, в идеале было бы лучше всего сделать так, чтобы у сообщений были отдельные поля
startLine или statusLine, headers и body. Затем, когда вызывается какой-то метод для определения какого-то значения,
это значение будет извлекаться из определённого поля и запоминаться, чтобы в следующий раз не тратить время на
повторное

Вообще проблема какого плана. У меня есть 2 класса, содержимое которых одинаковое в плане полей, у них
есть общие методы, но также у них есть и отличающиеся методы. У меня есть класс для чтения, чтение происходит
одинаково для сообщений обоих типов, то есть данные для создания экземпляров классов не отличаются, отличается лишь
наобор доступных методов. Вопрос: как мне в общем классе